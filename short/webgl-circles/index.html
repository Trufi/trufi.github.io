<!doctype html><html lang="ru_RU"><head> <meta charset="UTF-8"> <meta name="MobileOptimized" content="700"> <meta name="viewport" content="width=700"> <title>WebGL рисует не только треугольники</title> <link rel="stylesheet" href="/style.css"/></head><body> <div class="page"> <div class="header"> <ul class="topMenu">   <li class="topMenu__tab"><a href="/">Short</a></li>    <li class="topMenu__tab _disable"><span>Long</span></li>    <li class="topMenu__tab"><a href="/author">Author</a></li>   </ul></div> <div class="body"> <div class="article">  <h2>WebGL рисует не только треугольники</h2>  <div class="article__text"> <style> .showspoiler { color: #37abc9; cursor: pointer; } .spoiler, .spoilerdesc { display: none; }</style><p> <i>Возможно, суровые бородатые дядьки, которые вовсю разрабатывают на&nbsp;OpenGL закидают меня помидорами, но, когда я&nbsp;узнал об&nbsp;этом, то&nbsp;радовался как маленький ребёнок.</i></p><p> На&nbsp;протяжении последних двух месяцев я&nbsp;считал, что WebGL только и&nbsp;умеет, что рисовать только треугольники.</p><div class="article__img"> <img src="./images/triangle.svg" alt="Треугольник" width="200"> <div class="article__imgDesc"> Да, треугольники, и больше ничего. </div></div><p> Чтобы нарисовать квадрат, ему нужно два треугольника:</p><div class="article__img"> <img src="./images/square.svg" alt="Квадрат из двух треугольников" width="200"></div><p> А&nbsp;чтобы нарисовать круг, нужно немного попотеть! И&nbsp;всё равно это будет не&nbsp;совсем круг:</p><div class="article__img"> <img src="./images/circle.svg" alt="Триангуляция круга" width="200"> <div class="article__imgDesc"> Сколько на картинке треугольников? 18! </div></div><p> Но неожиданно оказывается, что есть гораздо более простой и приятный способ:</p><div class="article__img"> <div style="position: relative; width: 200px; height: 200px; display: inline-block; text-align: left;"> <img style="position: absolute; width: 200px; display: none;" class="spoiler" src="./images/one_triangle.svg" alt="Один треугольник"> <img style="position: absolute; width: 200px;" src="./images/one_circle.svg" alt="Круг, нарисованный простым способом"> </div> <div class="article__imgDesc"> Как вы думаете, сколько здесь используется треугольников? <span class="showspoiler">Показать</span> <span class="spoilerdesc">1</span> </div></div><p> Мы&nbsp;знаем, что фрагментый шейдер вычисляется для каждого пикселя, а&nbsp;атрибуты переданные в&nbsp;него через вершинный шейдер линейно интерполируются между вершинами треугольника.</p><p> Значит, можно задать для вершин специальную систему координат, указав их местоположение и&nbsp;передав в&nbsp;шейдеры. Точно также как передаются uv-координаты при отрисовки текстуры.</p><div class="article__img"> <img src="./images/coord.svg" alt="Система координат" width="200"></div><p> Получается, что, когда вызывается фрагментый шейдер, мы&nbsp;знаем координаты пикселя в&nbsp;нашей системе координат и&nbsp;можем на&nbsp;их&nbsp;основе определить цвет.</p><p> Например, мы говорим, что, если пиксель находится в круге с центром (Cx, Cy) и радиусом R, т.е. <span class="article__img" style="display: inline-block; width: 100%; margin: 15px 0;"> <img src="./images/formula.svg" alt="(X - Cx)^2 + (Y - Cy)^2 < R^2" style="width: 300px; height: 40px;"> </span> то закрашиваем его в синий цвет.</p><p> Вместо круга, можно придумать что-нибудь и&nbsp;более интересное:</p><div class="article__img"> <canvas id="wheel"></canvas></div><script> (function() { var showSpoilerButtons = document.getElementsByClassName('showspoiler'); var spoilers = document.getElementsByClassName('spoiler'); var spoilerDescriptions = document.getElementsByClassName('spoilerdesc'); for (var i = 0; i < showSpoilerButtons.length; i++) { (function(i) { showSpoilerButtons[i].onclick = function() { showSpoilerButtons[i].style.display = 'none'; spoilers[i] && (spoilers[i].style.display = 'block'); spoilerDescriptions[i] && (spoilerDescriptions[i].style.display = 'inline'); }; })(i); } })();</script><script id="vertexShaderWheel" type="x-shader/x-vertex"> attribute vec3 vertexVector; attribute vec2 vc; varying vec2 u_vc; void main(void) { u_vc = vc; gl_Position = vec4(vertexVector, 1.0); }</script><script id="fragmentShaderWheel" type="x-shader/x-fragment"> precision mediump float; uniform float angle; varying vec2 u_vc; float minR = 0.15; void main(void) { vec2 c = vec2(0.27, 0.27); float R; if (mod(floor((atan(u_vc.y - c.y, u_vc.x - c.x) + angle) / (3.14 / 10.0)), 2.0) == 0.0) { R = 0.25; } else { R = 0.2; } float distance = (u_vc.x - c.x) * (u_vc.x - c.x) + (u_vc.y - c.y) * (u_vc.y - c.y); if (distance < R * R && distance > minR * minR) { gl_FragColor = vec4(0.2, 0.501, 0.0, 1.0); } else { gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); } }</script><script> (function() { function checkWebGl() { try { if (window.WebGLRenderingContext) { var canvas = document.createElement('canvas'); return Boolean(canvas.getContext('webgl') || canvas.getContext('experimental-webgl')); } } catch (error) {} } var size = [200, 200]; var pr = 2; var canvas = document.getElementById('wheel'); canvas.width = size[0] * pr; canvas.height = size[1] * pr; canvas.style.width = size[0] + 'px'; canvas.style.height = size[1] + 'px'; var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl'); gl.viewport(0, 0, size[0] * pr * 1.9, size[1] * pr * 1.9); var vertexShader = gl.createShader(gl.VERTEX_SHADER); var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(vertexShader, document.getElementById('vertexShaderWheel').text); gl.compileShader(vertexShader); if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) { console.log(gl.getShaderInfoLog(vertexShader)); } gl.shaderSource(fragmentShader, document.getElementById('fragmentShaderWheel').text); gl.compileShader(fragmentShader); if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) { console.log(gl.getShaderInfoLog(fragmentShader)); } var program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program); if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.log('Could not initialize shaders'); } var angleUniform = gl.getUniformLocation(program, 'angle'); var vertexVectorAttribution = gl.getAttribLocation(program, 'vertexVector'); var uvAttribution = gl.getAttribLocation(program, 'vc'); var vertexBuffer = gl.createBuffer(); var vertices = [ -1, -1, 0, 1, -1, 0, -1, 1, 0 ]; gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW); var uvBuffer = gl.createBuffer(); var uv = [ 0, 0, 1, 0, 0, 1 ]; gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uv), gl.STATIC_DRAW); var lastRenderTime = Date.now(); var angle = 0; function render() { requestAnimationFrame(render); var time = Date.now(); var dt = lastRenderTime - time; angle += dt / 10000; gl.clearColor(1.0, 1.0, 1.0, 1.0); gl.enable(gl.DEPTH_TEST); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); gl.useProgram(program); gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer); gl.enableVertexAttribArray(uvAttribution); gl.vertexAttribPointer(uvAttribution, 2, gl.FLOAT, false, 0, 0); gl.uniform1f(angleUniform, angle); gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.enableVertexAttribArray(vertexVectorAttribution); gl.vertexAttribPointer(vertexVectorAttribution, 3, gl.FLOAT, false, 0, 0); gl.drawArrays(gl.TRIANGLES, 0, 3); lastRenderTime = time; } render(); })();</script> </div>  <div class="article__date">08.10.2015</div> </div> </div>  </div></body></html>