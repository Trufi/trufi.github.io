<!doctype html><html lang="ru_RU"><head> <meta charset="UTF-8"> <meta name="twitter:card" content="summary" /> <meta name="twitter:site" content="@trufid" /> <meta name="twitter:title" content="WebGL рисует не только треугольники" /> <meta name="twitter:description" content="Небольшая заметка о том, что WebGL может рисовать не только триангулированные объекты" /> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>WebGL рисует не только треугольники</title> <link rel="stylesheet" href="/style.css"/></head><body> <div class="page"> <div class="header"> <ul class="topMenu">   <li class="topMenu__tab"><a href="/">Short</a></li>    <li class="topMenu__tab _disable"><span>Long</span></li>    <li class="topMenu__tab"><a href="/author">Author</a></li>   </ul></div> <div class="body"> <div class="article">  <h2>WebGL рисует не только треугольники</h2>  <div class="article__text"> <style> .showspoiler { color: #37abc9; cursor: pointer; } .spoiler, .spoilerdesc { display: none; }</style><p> <i>Возможно, суровые бородатые дядьки, которые вовсю разрабатывают на&nbsp;OpenGL, закидают меня помидорами, но когда я&nbsp;узнал об&nbsp;этом, радовался как маленький ребёнок.</i></p><p> На&nbsp;протяжении последних двух месяцев я&nbsp;считал, что WebGL только и&nbsp;умеет, что рисовать треугольники.</p><div class="article__img"> <img src="./images/triangle.svg" alt="Треугольник" width="200"> <div class="article__imgDesc"> Да, треугольники, и больше ничего. </div></div><p> Например, чтобы нарисовать квадрат, ему нужно два треугольника:</p><div class="article__img"> <img src="./images/square.svg" alt="Квадрат из двух треугольников" width="200"></div><p> А&nbsp;чтобы нарисовать круг, придётся немного попотеть! И&nbsp;всё равно, это будет не&nbsp;совсем круг:</p><div class="article__img"> <img src="./images/circle.svg" alt="Триангуляция круга" width="200"> <div class="article__imgDesc"> Сколько на картинке треугольников? 18! </div></div><p> Но неожиданно оказывается, что есть более простой способ:</p><div class="article__img"> <div style="position: relative; width: 200px; height: 200px; display: inline-block; text-align: left;"> <img style="position: absolute; width: 200px; display: none;" class="spoiler" src="./images/one_triangle.svg" alt="Один треугольник"> <img style="position: absolute; width: 200px;" src="./images/one_circle.svg" alt="Круг, нарисованный простым способом"> </div> <div class="article__imgDesc"> Как вы думаете, сколько здесь используется треугольников? <span class="showspoiler">Показать</span> <span class="spoilerdesc">Всего 1!</span> </div></div><p> Мы&nbsp;знаем, что фрагментый шейдер вычисляется для каждого пикселя, а&nbsp;атрибуты, переданные в&nbsp;него через вершинный шейдер, линейно интерполируются между вершинами треугольника.</p><p> Значит, можно задать специальную систему координат, в&nbsp;которой укажем местоположение вершин треугольника и передадим их в&nbsp;шейдеры. Точно так же, как передаются uv-координаты при отрисовке текстуры.</p><div class="article__img"> <img src="./images/coord.svg" alt="Система координат" width="200"></div><p> Получается, что когда вызывается фрагментый шейдер, мы&nbsp;знаем положение пикселя в&nbsp;новой системе координат и&nbsp;можем на&nbsp;их&nbsp;основе вычислить цвет.</p><p> На примере выше мы говорим, что если пиксель находится в круге с&nbsp;центром&nbsp;(Cx,&nbsp;Cy) и&nbsp;радиусом&nbsp;R, т.е. <span class="article__img" style="display: inline-block; width: 100%; margin: 15px 0;"> <img src="./images/formula.svg" alt="(X - Cx)^2 + (Y - Cy)^2 < R^2" style="width: 300px; height: 40px;"> </span> то закрашиваем его в синий цвет.</p><p> Вместо круга можно придумать что-нибудь более интересное:</p><div class="article__img"> <div id="wheel"> <div id="wheel-without-webgl" class="article__img" style="display: none;"> <img src="./images/wheel.png" alt="Шестерёнка, если нет WebGL" width="200"> <div class="article__imgDesc"> Увы, шестерёнка не крутится, т.к. ваш браузер не поддерживает WebGL :( </div> </div> </div></div><script> (function() { var showSpoilerButtons = document.getElementsByClassName('showspoiler'); var spoilers = document.getElementsByClassName('spoiler'); var spoilerDescriptions = document.getElementsByClassName('spoilerdesc'); for (var i = 0; i < showSpoilerButtons.length; i++) { (function(i) { showSpoilerButtons[i].onclick = function() { showSpoilerButtons[i].style.display = 'none'; spoilers[i] && (spoilers[i].style.display = 'block'); spoilerDescriptions[i] && (spoilerDescriptions[i].style.display = 'inline'); }; })(i); } })();</script><script id="vertexShaderWheel" type="x-shader/x-vertex"> attribute vec3 vertexVector; attribute vec2 vc; varying vec2 u_vc; void main(void) { u_vc = vc; gl_Position = vec4(vertexVector, 1.0); }</script><script id="fragmentShaderWheel" type="x-shader/x-fragment"> precision mediump float; uniform float angle; varying vec2 u_vc; float minR = 0.15; void main(void) { vec2 c = vec2(0.27, 0.27); float R; if (mod(floor((atan(u_vc.y - c.y, u_vc.x - c.x) + angle) / (3.14 / 10.0)), 2.0) == 0.0) { R = 0.25; } else { R = 0.2; } float distance = (u_vc.x - c.x) * (u_vc.x - c.x) + (u_vc.y - c.y) * (u_vc.y - c.y); if (distance < R * R && distance > minR * minR) { gl_FragColor = vec4(0.2, 0.501, 0.0, 1.0); } else { gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); } }</script><script> (function() { function checkWebGL() { try { if (window.WebGLRenderingContext) { var canvas = document.createElement('canvas'); return Boolean(canvas.getContext('webgl') || canvas.getContext('experimental-webgl')); } } catch (error) {} } if (!checkWebGL()) { document.getElementById('wheel-without-webgl').style.display = 'block'; return; } var size = [200, 200]; var pr = 2; var container = document.getElementById('wheel'); var canvas = document.createElement('canvas'); canvas.width = size[0] * pr; canvas.height = size[1] * pr; canvas.style.width = size[0] + 'px'; canvas.style.height = size[1] + 'px'; container.appendChild(canvas); var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl'); gl.viewport(0, 0, size[0] * pr * 1.9, size[1] * pr * 1.9); var vertexShader = gl.createShader(gl.VERTEX_SHADER); var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(vertexShader, document.getElementById('vertexShaderWheel').text); gl.compileShader(vertexShader); if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) { console.log(gl.getShaderInfoLog(vertexShader)); } gl.shaderSource(fragmentShader, document.getElementById('fragmentShaderWheel').text); gl.compileShader(fragmentShader); if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) { console.log(gl.getShaderInfoLog(fragmentShader)); } var program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program); if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.log('Could not initialize shaders'); } var angleUniform = gl.getUniformLocation(program, 'angle'); var vertexVectorAttribution = gl.getAttribLocation(program, 'vertexVector'); var uvAttribution = gl.getAttribLocation(program, 'vc'); var vertexBuffer = gl.createBuffer(); var vertices = [ -1, -1, 0, 1, -1, 0, -1, 1, 0 ]; gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW); var uvBuffer = gl.createBuffer(); var uv = [ 0, 0, 1, 0, 0, 1 ]; gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uv), gl.STATIC_DRAW); var lastRenderTime = Date.now(); var angle = 0; gl.useProgram(program); gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer); gl.enableVertexAttribArray(uvAttribution); gl.vertexAttribPointer(uvAttribution, 2, gl.FLOAT, false, 0, 0); gl.uniform1f(angleUniform, angle); gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.enableVertexAttribArray(vertexVectorAttribution); gl.vertexAttribPointer(vertexVectorAttribution, 3, gl.FLOAT, false, 0, 0); function render() { requestAnimationFrame(render); var time = Date.now(); var dt = lastRenderTime - time; angle += dt / 10000; gl.uniform1f(angleUniform, angle); gl.clearColor(1.0, 1.0, 1.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, 3); lastRenderTime = time; } render(); })();</script> </div> <div class="article__bottom">  <div class="article__date">13.10.2015</div> <div class="article_toTopButton" onclick="window.scrollTo(0,0)">Наверх</div>  </div></div> </div>  </div> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-68814901-1', 'auto'); ga('send', 'pageview'); </script></body></html>