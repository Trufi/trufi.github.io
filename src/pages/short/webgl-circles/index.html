<p>
    Возможно, суровые бородатые дядьки, которые вовсю разрабатывают на OpenGL закидают меня помидорами, но я радовался как маленький ребёнок. На протяжении последних двух месяцев я считал и всем об этом рассказывал, что WebGL умеет рисовать только треугольники. Да, треугольники, и больше ничего.
</p>

<img src="" alt="Треугольник">

<p>
    Чтобы нарисовать квадрат, ему нужно два треугольника.
</p>

<img src="" alt="Квадрат из двух треугольников">

<p>
    А чтобы нарисовать круг, нужно немного попотеть! И всё равно это будет не совсем круг:
</p>

<img src="" alt="Триангуляция круга">

<p>Сколько на картинке выше треугольников? 52</p>

<p>
    Но неожиданно оказывается, что есть гораздо более простой и приятный способ это сделать:
</p>

<img src="" alt="Круг, нарисованный простым способом">

<p>
    Как вы думаете, сколько здесь используется треугольников? 1
</p>

<p>
    Мы знаем, что фрагментый шейдер вычисляется для каждого пикселя, а атрибуты переданные в него через вершинный шейдер линейно интерполируются между вершиными треугольника. Значит можно задать для вершин систему координат, указать местопложение вершин и передать. Точно также как передаются uv-координаты при отрисовки текстуры.
</p>

<p>
    Получается, что, когда вызывается фрагментый шейдер, мы знаем координаты пикселя относительно вершинной системы координат и можем на их основе определить, какой цвет он примет.
</p>

<p>
    Например, мы можем сказать, что, если пиксель находится в круге с центром [Xc, Yc] и радиусом R:
</p>

<code>
    if ((X - Xc)^2 - (Y - Yc)^2 < R^2)
</code>

<p>
    то закрашивать его в чёрный цвет.
</p>


webgl пример

<p>
    Можно придумать ещё уйму способов, например:
</p>

webgl пример с шестеренкой
